\documentclass{beamer}
\usefonttheme[onlymath]{serif}

\usepackage{braket}
\usepackage{tikz}

\input{macros}

\usetikzlibrary{shapes.callouts}
\usetikzlibrary{cd}
\usetheme{Copenhagen}

\title{Constant-round Blind Classical Verification of Quantum Sampling}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Settings}

	\begin{tikzpicture}
		\node[ellipse callout, callout relative pointer={(200:2cm)}, draw] (n1) {I've got a quantum computer to rent you...};
	\end{tikzpicture}

	\onslide<2->
	\begin{flushright}
		\begin{tikzpicture}
			\node[ellipse callout, callout relative pointer={(340:2cm)}, draw] (n2) {You scamming me mate?};
		\end{tikzpicture}
	\end{flushright}
\end{frame}

\begin{frame}
	\frametitle{Goal: $\BQP$? $\SampBQP$?}

    $\SampBQP$ is the class of sampling problems $\left(D_x\right)_{x\in\set{0, 1}^*}$ that can be (approximately) sampled by polynomial-size uniform quantum circuits. Namely, there exists a Turing machine $M$ such that for every $n \in \bbN$ and $\eps \in (0,1)$, $M(1^n, 1^{1/\eps})$ outputs a quantum circuit $C$ in $\poly(n, 1/\eps)$ time such that for every $x \in \zo^n$, the output of $C(x)$ (measured in standard basis) is $\eps$-close to $D_x$.

\end{frame}

\begin{frame}
	\frametitle{How might I get scammed?}
	\begin{itemize}[<+->]
		\item It doesn't even work! (correctness) (Solved for BQP)
		\item Stolen data (privacy)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Quantum Homomorphic Encryption Schemes}

	$$(pk, sk)\leftarrow\Gen(\lambda)$$

	\begin{center}

		\begin{tikzcd}[row sep = 4.8em, column sep = 9.6em]
			X \rar["f(\,\cdot\,)"] \dar["{\Enc(pk, \,\cdot\,)}"] & Y \\
			\hat{X} \rar["{\Eval(pk, f, \,\cdot\,)}"] & \uar["{\Dec(sk, \,\cdot\,)}"] \hat{Y}
		\end{tikzcd}
	
	\end{center}

\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Generic $\Pi=(P, V)(\lambda, x)$}
	$(v_1, st_{V, 1})\leftarrow\cV_1(1^\lambda, x)$
	\pause
	\\\hspace*{\fill}$\xrightarrow{\qquad v_1\qquad}$\hspace*{\fill}
	\pause
	\\\hspace*{\fill}$(p_1, st_{P, 1})\leftarrow\cP_1(1^\lambda, v_1, x)$
	\pause
	\\\hspace*{\fill}$\xleftarrow{\qquad p_1\qquad}$\hspace*{\fill}
	\pause
	\\$(v_2, st_{V, 2})\leftarrow\cV_2(p_1, st_{V, 1})$
	\pause
	\\\hspace*{\fill}$\xrightarrow{\qquad v_2\qquad}$\hspace*{\fill}
	\pause
	\\\hspace*{\fill}$(p_2, st_{P, 2})\leftarrow\cP_2(v_1, st_{P, 1})$
	\pause
	\\\hspace*{\fill}$\xleftarrow{\qquad p_2\qquad}$\hspace*{\fill}
	\pause
	\\$(v_3, st_{V, 3})\leftarrow\cV_3(p_2, st_{V, 2})$
	\pause
	$$\vdots$$
	\pause
	$o\leftarrow\cV_{out}(p_T, st_{V,T})$
\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Our construction}

\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Correctness}

\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Blindness}

\end{frame}

\begin{frame}
	\frametitle{Verification under $\QPIP_1$ protocols}
	MF16 for BQP
	Different Hamiltonian for SampBQP

	Hcircuit and Hout
\end{frame}

\begin{frame}
	\frametitle{Mahadev's measurement protocol}

\end{frame}

\begin{frame}
	\frametitle{Parallel repetitions of measurement protocol?}

\end{frame}

\end{document}
