\documentclass{beamer}
\usefonttheme[onlymath]{serif}

\usepackage{braket}
\usepackage{tikz}

\input{macros}

\usetikzlibrary{shapes.callouts}
\usetikzlibrary{cd}
\usetheme{Copenhagen}

\title{Constant-round Blind Classical Verification of Quantum Sampling}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Settings}

	\begin{tikzpicture}
		\node[ellipse callout, callout relative pointer={(200:2cm)}, draw] (n1) {I've got a quantum computer to rent you...};
	\end{tikzpicture}

	\onslide<2->
	\begin{flushright}
		\begin{tikzpicture}
			\node[ellipse callout, callout relative pointer={(340:2cm)}, draw] (n2) {You scamming me mate?};
		\end{tikzpicture}
	\end{flushright}
\end{frame}

\begin{frame}
	\frametitle{Goal: $\BQP$? $\SampBQP$?}

    $\SampBQP$ is the class of sampling problems $\left(D_x\right)_{x\in\set{0, 1}^*}$ that can be (approximately) sampled by polynomial-size uniform quantum circuits. Namely, there exists a Turing machine $M$ such that for every $n \in \bbN$ and $\eps \in (0,1)$, $M(1^n, 1^{1/\eps})$ outputs a quantum circuit $C$ in $\poly(n, 1/\eps)$ time such that for every $x \in \zo^n$, the output of $C(x)$ (measured in standard basis) is $\eps$-close to $D_x$.

\end{frame}

\begin{frame}
	\frametitle{How might I get scammed?}
	\begin{itemize}[<+->]
		\item It doesn't even work! (correctness) (Solved for BQP)
		\item Stolen data (privacy)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Quantum Homomorphic Encryption Schemes}

	$$(pk, sk)\leftarrow\Gen(\lambda, 1^L)$$

	\begin{center}

		\begin{tikzcd}[row sep = 4.8em, column sep = 9.6em]
			X \rar["f(\,\cdot\,)"] \dar["{\Enc(pk, \,\cdot\,)}"] & Y \\
			\hat{X} \rar["{\Eval(pk, f, \,\cdot\,)}"] & \uar["{\Dec(sk, \,\cdot\,)}"] \hat{Y}
		\end{tikzcd}
	
	\end{center}

\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Generic $\Pi=(P, V)(\lambda, x)$}
	\pause
	$(v_1, st_{V, 1})\leftarrow\cV_1(1^\lambda, x)$
	\pause
	\\\hspace*{\fill}$\xrightarrow{\qquad v_1\qquad}$\hspace*{\fill}
	\pause
	\\\hspace*{\fill}$(p_1, st_{P, 1})\leftarrow\cP_1(1^\lambda, v_1, x)$
	\pause
	\\\hspace*{\fill}$\xleftarrow{\qquad p_1\qquad}$\hspace*{\fill}
	\pause
	\\$(v_2, st_{V, 2})\leftarrow\cV_2(p_1, st_{V, 1})$
	\pause
	\\\hspace*{\fill}$\xrightarrow{\qquad v_2\qquad}$\hspace*{\fill}
	\pause
	\\\hspace*{\fill}$(p_2, st_{P, 2})\leftarrow\cP_2(v_1, st_{P, 1})$
	\pause
	\\\hspace*{\fill}$\xleftarrow{\qquad p_2\qquad}$\hspace*{\fill}
	\pause
	\\$(v_3, st_{V, 3})\leftarrow\cV_3(p_2, st_{V, 2})$
	\pause
	$$\vdots$$
	\pause
	$o\leftarrow\cV_{out}(p_T, st_{V,T})$
\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Our $\Pi_\blind=(P_\blind, V_\blind(x))(\lambda)$}
	$(v_1, st_{V, 1})\leftarrow\cV_1(1^\lambda, x)$
	\pause
	\\$(pk_1, sk_1)\leftarrow\Gen(1^\lambda, 1^L)$
	\pause
	\\$\ctx{x}{}{1}\leftarrow\Enc(pk_1, x)$
	\pause
	\\$\ctx{v}{1}{1}\leftarrow\Enc(pk_1, v_1)$
	\pause
	\\\hspace*{\fill}$\xrightarrow{\qquad pk_1, \ctx{x}{}{1}, \ctx{v}{1}{1}\qquad}$\hspace*{\fill}
	\pause
	\\\hspace*{\fill}$\widehat{1^\lambda}\leftarrow\Enc(pk_1, 1^\lambda)$
	\pause
	\\\hspace*{\fill}$(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\Eval(pk, \cP_1, \widehat{1^\lambda}, \ctx{v}{1}{1}, \ctx{x}{}{1})$
	\pause
	\\\hspace*{\fill}$\xleftarrow{\qquad \ctx{p}{1}{1}\qquad}$\hspace*{\fill}
	\pause
	\\$p_1\leftarrow\Dec(sk_1, \ctx{p}{1}{1})$
\end{frame}

\begin{frame}
	\frametitle{$\Pi_\blind=(P_\blind, V_\blind(x))(\lambda)$ cont.}
	$v_i\leftarrow\cV_2(p_{i-1}, st_{V, i-1})$

\end{frame}

\iffalse
        \item for $t=2,\ldots,T$:
        \begin{enumerate}
            \item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec(sk_{t-1}, \ctx{p}{t-1}{t-1})$,
                then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
                Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$,
                and produces encryptions $\ctx{v}{t}{t}\leftarrow\QEnc(pk_t, v_t)$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc(pk_t, sk_{t-1})$.
                It sends $pk_t$, $\ctx{v}{t}{t}$, and $\ctx{sk}{t-1}{t}$ to the prover.
            \item $\Pblind$ generates $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$
                by first switching its encryption key;
                that is, it encrypts its state under the new key by $\ctx{st}{P, t-1}{t-1, t}\leftarrow\QEnc(pk_t, \ctx{st}{P, t-1}{t-1}))$,
                then homomorphically decrypts the old encryption by
                $\ctx{st}{P, t-1}{t}\leftarrow\QEval(pk_t, \QDec,$ \ $\ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1, t})$.
                Then it applies the next-message function homomorphically, generating
                $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\QEval(pk_t, \cP_t, \ctx{v}{t}{t}, \ctx{st}{P, t-1}{t})$.
                It sends $\ctx{p}{t}{t}$ back to the verifier.
        \end{enumerate}
        \item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec(sk_T, \ctx{p}{T}{T})$.
            It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
\fi


\begin{frame}
	\frametitle{Compiler for blindness: Correctness}

\end{frame}

\begin{frame}
	\frametitle{Compiler for blindness: Blindness}

\end{frame}

\begin{frame}
	\frametitle{Verification under $\QPIP_1$ protocols}
	MF16 for BQP
	Different Hamiltonian for SampBQP

	Hcircuit and Hout
\end{frame}

\begin{frame}
	\frametitle{Mahadev's measurement protocol}

\end{frame}

\begin{frame}
	\frametitle{Parallel repetitions of measurement protocol?}

\end{frame}

\end{document}
